<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fragments | A Time-Rewind Platformer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0f;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Georgia', serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
        }

        #gameCanvas {
            display: block;
            border: 4px double #8b7355;
            box-shadow:
                0 0 60px rgba(100, 200, 255, 0.15),
                inset 0 0 100px rgba(40, 60, 80, 0.8);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #a8b8c8;
            font-size: 14px;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        #ui .label {
            color: #8b7355;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
        }

        #ui .value {
            color: #e0c097;
            font-size: 18px;
            font-weight: bold;
        }

        #timeBar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid #555;
        }

        #timeBarFill {
            height: 100%;
            background: linear-gradient(90deg, #e67e22, #f1c40f);
            transition: width 0.1s;
            box-shadow: 0 0 10px #e67e22;
        }

        #rewindIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e74c3c;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 20px #c0392b;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        #rewindIndicator.active {
            opacity: 1;
        }

        #controls {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #7f8c8d;
            font-size: 11px;
            text-align: center;
            pointer-events: none;
        }

        #emotionIndicator {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            pointer-events: none;
        }

        #emotionIndicator .state {
            font-size: 24px;
            margin-bottom: 4px;
        }

        #emotionIndicator .label {
            color: #8b7355;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Courier New', monospace;
        }

        .fragment-count {
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        /* Rewind visual overlay */
        #rewindOverlay {
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(100, 100, 255, 0.1) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        #rewindOverlay.active {
            opacity: 1;
        }

        /* Scanlines for retro feel */
        #scanlines {
            position: absolute;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="960" height="540"></canvas>

        <div id="ui">
            <div class="label">Memories</div>
            <div class="value fragment-count"><span id="fragmentCount">0</span> / <span id="fragmentTotal">5</span></div>
        </div>

        <div id="emotionIndicator">
            <div class="state" id="emotionEmoji">üòê</div>
            <div class="label" id="emotionLabel">NORMAL</div>
        </div>

        <div id="timeBar">
            <div id="timeBarFill" style="width: 100%"></div>
        </div>

        <div id="rewindIndicator">‚óÄ‚óÄ REWINDING ‚óÄ‚óÄ</div>

        <div id="controls">
            ARROWS to move ¬∑ SPACE to jump (x2) ¬∑ HOLD SHIFT to rewind
        </div>

        <div id="rewindOverlay"></div>
        <div id="scanlines"></div>
    </div>

    <script>
// =============================================================================
// FRAGMENTS - A Time-Rewind Platformer
// =============================================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Helper for animation
const lerp = (start, end, amt) => (1 - amt) * start + amt * end;

// Van Gogh Sky System (Brush Strokes)
const brushes = Array.from({ length: 2000 }, () => ({
    x: Math.random() * 960,
    y: Math.random() * 540,
    length: Math.random() * 20 + 10,
    angle: Math.random() * Math.PI * 2,
    speed: Math.random() * 0.3 + 0.1,
    hue: Math.random() * 60 + 160, // Wider range of Teals/Blues/Greens
    width: Math.random() * 2 + 1
}));

// Sprite System
const SPRITES = {
    player: new Image(),
    tiles: new Image()
};

SPRITES.player.onload = () => console.log('Player sprite loaded:', SPRITES.player.width, 'x', SPRITES.player.height);
SPRITES.tiles.onload = () => console.log('Tiles sprite loaded:', SPRITES.tiles.width, 'x', SPRITES.tiles.height);

// UNCOMMENT THESE LINES WHEN YOU HAVE IMAGES:
SPRITES.player.src = 'player.png';  // Expects 32x32 frames: Row 0=Idle, 1=Run, 2=Jump
SPRITES.tiles.src = 'tiles.png';    // Expects 32x32 tiles

// -----------------------------------------------------------------------------
// CONFIGURATION
// -----------------------------------------------------------------------------
const CONFIG = {
    TILE_SIZE: 32,
    GRAVITY: 0.6,
    JUMP_FORCE: -13,
    MOVE_SPEED: 5,
    MAX_TIME_HISTORY: 1200, // Increased to 20 seconds
    REWIND_SPEED: 3,        // Rewind 3x faster
    FRICTION: 0.85,
    AIR_RESISTANCE: 0.95
};

// -----------------------------------------------------------------------------
// EMOTIONAL STATES
// -----------------------------------------------------------------------------
const EMOTIONS = {
    NORMAL: {
        name: 'NORMAL',
        emoji: 'üòê',
        color: '#e67e22', // Warm Orange spirit
        jumpMod: 1,
        speedMod: 1,
        description: 'Balanced. Steady.'
    },
    HURT: {
        name: 'HURT',
        emoji: 'üò¢',
        color: '#c0392b', // Deep Red
        jumpMod: 1.0, // Normalized to prevent inconsistency
        speedMod: 0.7,
        description: 'Heavy. Slower.'
    },
    NUMB: {
        name: 'NUMB',
        emoji: 'üò∂',
        color: '#95a5a6', // Ghostly Grey
        jumpMod: 0.9, // Buffed from 0.6 to keep platforming viable
        speedMod: 0.5,
        canPhase: true, // Can pass through certain platforms
        description: 'Detached. Can phase through memories.'
    },
    HOPEFUL: {
        name: 'HOPEFUL',
        emoji: 'üôÇ',
        color: '#f1c40f', // Bright Gold
        jumpMod: 1.3,
        speedMod: 1.2,
        description: 'Light. Elevated.'
    }
};

// -----------------------------------------------------------------------------
// GAME STATE
// -----------------------------------------------------------------------------
const game = {
    player: null,
    level: null,
    fragments: [],
    timeHistory: [],
    isRewinding: false,
    fragmentsCollected: 0,
    currentEmotion: EMOTIONS.NORMAL,
    particles: [],
    camera: { x: 0, y: 0 },
    ghostTrail: [],
    shake: 0,
    won: false
};

// -----------------------------------------------------------------------------
// INPUT HANDLING
// -----------------------------------------------------------------------------
const keys = {
    left: false,
    right: false,
    up: false,
    jump: false,
    rewind: false
};

document.addEventListener('keydown', (e) => {
    switch(e.code) {
        case 'ArrowLeft':
        case 'KeyA':
            keys.left = true;
            break;
        case 'ArrowRight':
        case 'KeyD':
            keys.right = true;
            break;
        case 'ArrowUp':
        case 'KeyW':
            keys.up = true;
            break;
        case 'Space':
            keys.jump = true;
            e.preventDefault();
            break;
        case 'ShiftLeft':
        case 'ShiftRight':
            keys.rewind = true;
            e.preventDefault();
            break;
        case 'KeyR':
            if (game.won) location.reload();
            break;
    }
});

document.addEventListener('keyup', (e) => {
    switch(e.code) {
        case 'ArrowLeft':
        case 'KeyA':
            keys.left = false;
            break;
        case 'ArrowRight':
        case 'KeyD':
            keys.right = false;
            break;
        case 'ArrowUp':
        case 'KeyW':
            keys.up = false;
            break;
        case 'Space':
            keys.jump = false;
            break;
        case 'ShiftLeft':
        case 'ShiftRight':
            keys.rewind = false;
            break;
    }
});

// -----------------------------------------------------------------------------
// PLAYER CLASS
// -----------------------------------------------------------------------------
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 24;
        this.height = 32;
        this.vx = 0;
        this.vy = 0;
        this.onGround = false;
        this.facingRight = true;
        this.jumpHeld = false;
        this.scaleX = 1;
        this.scaleY = 1;
        this.coyoteTime = 0;
        this.jumpCount = 0;
        this.maxJumps = 2;
        this.animTimer = 0;
        this.frame = 0;
        this.action = 'idle';
    }

    update() {
        const emotion = game.currentEmotion;
        const speed = CONFIG.MOVE_SPEED * emotion.speedMod;
        const wasOnGround = this.onGround;

        // Coyote Time (allow jumping shortly after falling off ledge)
        if (this.onGround) {
            this.coyoteTime = 6; // 6 frames grace period
            this.jumpCount = 0;
        } else {
            this.coyoteTime--;
        }

        // Animation State Logic
        if (!this.onGround) this.action = 'jump';
        else if (Math.abs(this.vx) > 0.5) this.action = 'run';
        else this.action = 'idle';

        // Animation Frame Ticking
        this.animTimer++;
        if (this.animTimer > 6) { // ~10 FPS
            this.frame = (this.frame + 1) % 4; // Assuming 4 frames per row
            this.animTimer = 0;
        }

        // Squash and stretch recovery
        this.scaleX = lerp(this.scaleX, 1, 0.2);
        this.scaleY = lerp(this.scaleY, 1, 0.2);

        // Horizontal movement
        if (keys.left) {
            this.vx -= speed * 0.3;
            this.facingRight = false;
        }
        if (keys.right) {
            this.vx += speed * 0.3;
            this.facingRight = true;
        }

        // Clamp horizontal velocity
        this.vx = Math.max(-speed, Math.min(speed, this.vx));

        // Apply friction
        if (this.onGround) {
            this.vx *= CONFIG.FRICTION;
        } else {
            this.vx *= CONFIG.AIR_RESISTANCE;
        }

        // Jumping
        if (keys.jump && !this.jumpHeld) {
            let jumped = false;
            
            if (this.coyoteTime > 0) {
                this.vy = CONFIG.JUMP_FORCE * emotion.jumpMod;
                this.coyoteTime = 0;
                this.jumpCount = 1;
                jumped = true;
            } else if (this.jumpCount < this.maxJumps) {
                this.vy = CONFIG.JUMP_FORCE * emotion.jumpMod * 0.9;
                this.jumpCount++;
                jumped = true;
            }

            if (jumped) {
                this.onGround = false;
                this.jumpHeld = true;
                spawnJumpParticles(this.x + this.width/2, this.y + this.height);
                this.scaleX = 0.6;
                this.scaleY = 1.4;
            }
        }
        if (!keys.jump) {
            this.jumpHeld = false;
        }

        // Variable jump height - release early for shorter jump
        if (!keys.jump && this.vy < 0) {
            this.vy *= 0.6;
        }

        // Gravity
        this.vy += CONFIG.GRAVITY;
        this.vy = Math.min(this.vy, 15); // Terminal velocity

        // Apply movement
        this.x += this.vx;
        this.y += this.vy;

        // Collision detection
        this.handleCollisions();

        // Keep in bounds
        this.x = Math.max(0, Math.min(this.x, game.level.width * CONFIG.TILE_SIZE - this.width));

        // Fall death
        if (this.y > game.level.height * CONFIG.TILE_SIZE + 100) {
            this.respawn();
        }

        // Landing impact
        if (!wasOnGround && this.onGround) {
            this.scaleX = 1.4;
            this.scaleY = 0.6;
            game.shake = 4;
            spawnJumpParticles(this.x + this.width/2, this.y + this.height);
        }
    }

    handleCollisions() {
        const tileSize = CONFIG.TILE_SIZE;
        this.onGround = false;

        // Get tiles player might be touching
        const left = Math.floor(this.x / tileSize);
        const right = Math.floor((this.x + this.width) / tileSize);
        const top = Math.floor(this.y / tileSize);
        const bottom = Math.floor((this.y + this.height) / tileSize);

        for (let ty = top; ty <= bottom; ty++) {
            for (let tx = left; tx <= right; tx++) {
                const tile = getTile(tx, ty);

                if (tile === 1) { // Solid tile
                    const tileRect = {
                        x: tx * tileSize,
                        y: ty * tileSize,
                        width: tileSize,
                        height: tileSize
                    };

                    if (this.intersects(tileRect)) {
                        this.resolveCollision(tileRect);
                    }
                } else if (tile === 2 && !game.currentEmotion.canPhase) {
                    // Platform - only solid from above, unless NUMB
                    const tileRect = {
                        x: tx * tileSize,
                        y: ty * tileSize,
                        width: tileSize,
                        height: tileSize
                    };

                    // Only collide if falling down onto it
                    if (this.vy > 0 && this.y + this.height - this.vy <= tileRect.y) {
                        if (this.x + this.width > tileRect.x && this.x < tileRect.x + tileRect.width) {
                            this.y = tileRect.y - this.height;
                            this.vy = 0;
                            this.onGround = true;
                        }
                    }
                }
            }
        }
    }

    intersects(rect) {
        return this.x < rect.x + rect.width &&
               this.x + this.width > rect.x &&
               this.y < rect.y + rect.height &&
               this.y + this.height > rect.y;
    }

    resolveCollision(rect) {
        const overlapX = Math.min(this.x + this.width - rect.x, rect.x + rect.width - this.x);
        const overlapY = Math.min(this.y + this.height - rect.y, rect.y + rect.height - this.y);

        if (overlapX < overlapY) {
            // Horizontal collision
            if (this.x + this.width/2 < rect.x + rect.width/2) {
                this.x = rect.x - this.width;
            } else {
                this.x = rect.x + rect.width;
            }
            this.vx = 0;
        } else {
            // Vertical collision
            if (this.y + this.height/2 < rect.y + rect.height/2) {
                this.y = rect.y - this.height;
                this.vy = 0;
                this.onGround = true;
            } else {
                this.y = rect.y + rect.height;
                this.vy = 0;
            }
        }
    }

    respawn() {
        this.x = game.level.spawn.x * CONFIG.TILE_SIZE;
        this.y = game.level.spawn.y * CONFIG.TILE_SIZE;
        this.vx = 0;
        this.vy = 0;
    }

    getState() {
        return {
            x: this.x,
            y: this.y,
            vx: this.vx,
            vy: this.vy,
            onGround: this.onGround,
            facingRight: this.facingRight
        };
    }

    setState(state) {
        this.x = state.x;
        this.y = state.y;
        this.vx = state.vx;
        this.vy = state.vy;
        this.onGround = state.onGround;
        this.facingRight = state.facingRight;
    }

    draw() {
        const emotion = game.currentEmotion;

        ctx.save();
        // Pivot point for scaling (bottom center)
        ctx.translate(this.x + this.width/2, this.y + this.height);
        ctx.scale(this.scaleX, this.scaleY);
        
        // CHECK: Do we have a sprite loaded?
        if (SPRITES.player.complete && SPRITES.player.naturalWidth !== 0) {
            const img = SPRITES.player;
            
            // Heuristic: Is this a sprite sheet or a single image?
            // Assume sprite sheet ONLY if it looks like a strip (Width >= 2x Height)
            // OR if it matches our specific 32x32 grid template (128 width)
            const isStrip = (img.width >= img.height * 2);
            const isGrid = (img.width === 128 && img.height <= 96);
            
            let srcX = 0, srcY = 0, srcW = img.width, srcH = img.height;
            
            if (isStrip || isGrid) {
                const frameSize = 32;
                let row = 0;
                if (img.height >= 96) {
                    if (this.action === 'run') row = 1;
                    if (this.action === 'jump') row = 2;
                }
                
                // Cycle frames safely
                const numFrames = Math.floor(img.width / frameSize) || 1;
                const col = this.frame % numFrames;
                
                srcX = col * frameSize;
                srcY = row * frameSize;
                srcW = frameSize;
                srcH = frameSize;
            }
            
            // Flip sprite if facing left
            ctx.save();
            ctx.scale(this.facingRight ? 1 : -1, 1);
            ctx.drawImage(
                img,
                srcX, srcY, srcW, srcH, // Source
                -16, -32, 32, 32        // Destination (centered on feet)
            );
            ctx.restore();
        } else {
            // FALLBACK: Procedural Spirit Flame
            ctx.beginPath();
            ctx.moveTo(-this.width/2, -this.height);
            ctx.quadraticCurveTo(0, -this.height - 10 + Math.sin(Date.now() * 0.01) * 5, this.width/2, -this.height);
            ctx.lineTo(this.width/2, 0);
            ctx.lineTo(-this.width/2, 0);
            ctx.closePath();
            
            ctx.fillStyle = emotion.color;
            ctx.fill();
            
            // Inner light
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(0, -this.height/2, 6, 0, Math.PI * 2);
            ctx.fill();
        }

        // Glow effect (Painterly halo)
        ctx.shadowColor = emotion.color;
        ctx.shadowBlur = 20;
        ctx.restore();
    }
}

// -----------------------------------------------------------------------------
// FRAGMENT (Collectible) CLASS
// -----------------------------------------------------------------------------
class Fragment {
    constructor(x, y, id) {
        this.x = x * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2;
        this.y = y * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE/2;
        this.radius = 8;
        this.collected = false;
        this.id = id;
        this.bobOffset = Math.random() * Math.PI * 2;
        this.pulsePhase = 0;

        // Time-immune: fragments don't rewind
        this.timeImmune = true;
    }

    update() {
        this.pulsePhase += 0.05;

        if (!this.collected) {
            // Check collection
            const dx = (game.player.x + game.player.width/2) - this.x;
            const dy = (game.player.y + game.player.height/2) - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < this.radius + 20) {
                this.collect();
                game.shake = 5;
                
                if (game.fragmentsCollected === game.fragments.length) {
                    game.won = true;
                }
            }
        }
    }

    collect() {
        this.collected = true;
        game.fragmentsCollected++;
        updateUI();

        // Spawn collection particles
        for (let i = 0; i < 20; i++) {
            game.particles.push(new Particle(
                this.x,
                this.y,
                (Math.random() - 0.5) * 8,
                (Math.random() - 0.5) * 8,
            '#f1c40f',
                30 + Math.random() * 30
            ));
        }

        // Maybe change emotion based on fragments collected
        updateEmotion();
    }

    draw() {
        if (this.collected) return;

        const bob = Math.sin(this.pulsePhase + this.bobOffset) * 4;
        const pulse = 1 + Math.sin(this.pulsePhase * 2) * 0.2;

        // Glow
        ctx.beginPath();
        ctx.arc(this.x, this.y + bob, this.radius * 2 * pulse, 0, Math.PI * 2);
        const gradient = ctx.createRadialGradient(
            this.x, this.y + bob, 0,
            this.x, this.y + bob, this.radius * 2 * pulse
        );
        gradient.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
        gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fill();

        // Core - diamond shape
        ctx.save();
        ctx.translate(this.x, this.y + bob);
        ctx.rotate(this.pulsePhase * 0.5);
        ctx.beginPath();
        ctx.moveTo(0, -this.radius * pulse);
        ctx.lineTo(this.radius * pulse * 0.7, 0);
        ctx.lineTo(0, this.radius * pulse);
        ctx.lineTo(-this.radius * pulse * 0.7, 0);
        ctx.closePath();
        ctx.fillStyle = '#ffd700';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
    }
}

// -----------------------------------------------------------------------------
// PARTICLE CLASS
// -----------------------------------------------------------------------------
class Particle {
    constructor(x, y, vx, vy, color, life) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.life = life;
        this.maxLife = life;
        this.size = 3 + Math.random() * 3;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1; // Gravity
        this.life--;
        return this.life > 0;
    }

    draw() {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

function spawnJumpParticles(x, y) {
    for (let i = 0; i < 8; i++) {
        game.particles.push(new Particle(
            x + (Math.random() - 0.5) * 20,
            y,
            (Math.random() - 0.5) * 4,
            Math.random() * -2,
            '#ecf0f1',
            20 + Math.random() * 20
        ));
    }
}

// -----------------------------------------------------------------------------
// LEVEL DATA
// -----------------------------------------------------------------------------
// 0 = empty, 1 = solid, 2 = platform (pass-through from below), 3 = fragment spawn
const LEVEL_1 = {
    name: "The Beginning",
    spawn: { x: 2, y: 12 },
    width: 30,
    height: 17,
    tiles: [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,0,0,3,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1],
        [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ],
    fragments: [] // Will be populated from tile data
};

function loadLevel(levelData) {
    game.level = levelData;
    game.fragments = [];
    game.fragmentsCollected = 0;

    // Find fragment positions from tile data
    let fragmentId = 0;
    for (let y = 0; y < levelData.tiles.length; y++) {
        for (let x = 0; x < levelData.tiles[y].length; x++) {
            if (levelData.tiles[y][x] === 3) {
                game.fragments.push(new Fragment(x, y, fragmentId++));
                levelData.tiles[y][x] = 0; // Clear the spawn marker
            }
        }
    }

    document.getElementById('fragmentTotal').textContent = game.fragments.length;

    // Create player
    game.player = new Player(
        levelData.spawn.x * CONFIG.TILE_SIZE,
        levelData.spawn.y * CONFIG.TILE_SIZE
    );

    // Reset time
    game.timeHistory = [];
    game.currentEmotion = EMOTIONS.NORMAL;
    updateUI();
}

function getTile(x, y) {
    if (y < 0 || y >= game.level.tiles.length) return 1;
    if (x < 0 || x >= game.level.tiles[0].length) return 1;
    return game.level.tiles[y][x];
}

// -----------------------------------------------------------------------------
// TIME SYSTEM
// -----------------------------------------------------------------------------
function recordTime() {
    const state = {
        player: game.player.getState(),
        fragments: game.fragments.map(f => ({ collected: f.collected })),
        emotion: game.currentEmotion
    };

    game.timeHistory.push(state);

    // Limit history
    if (game.timeHistory.length > CONFIG.MAX_TIME_HISTORY) {
        game.timeHistory.shift();
    }
}

function rewindTime() {
    // Rewind multiple frames per tick for speed
    for (let i = 0; i < CONFIG.REWIND_SPEED; i++) {
        if (game.timeHistory.length > 0) {
            const state = game.timeHistory.pop();
            game.player.setState(state.player);

            // Visual effects (only once per frame to save performance)
            if (i === 0) {
                // Add ghost trail effect
                game.ghostTrail.push({
                    x: state.player.x,
                    y: state.player.y,
                    alpha: 0.5,
                    width: game.player.width,
                    height: game.player.height
                });

                // Limit ghost trail
                if (game.ghostTrail.length > 20) {
                    game.ghostTrail.shift();
                }

                // Spawn rewind particles
                if (Math.random() < 0.3) {
                    game.particles.push(new Particle(
                        game.player.x + game.player.width/2,
                        game.player.y + game.player.height/2,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 3,
                        '#4a9eff',
                        20
                    ));
                }
            }
        }
    }
}

// -----------------------------------------------------------------------------
// EMOTION SYSTEM
// -----------------------------------------------------------------------------
function updateEmotion() {
    const total = game.fragments.length;
    const collected = game.fragmentsCollected;
    const ratio = collected / total;

    if (ratio === 0) {
        game.currentEmotion = EMOTIONS.NORMAL;
    } else if (ratio < 0.4) {
        game.currentEmotion = EMOTIONS.HURT;
    } else if (ratio < 0.7) {
        game.currentEmotion = EMOTIONS.NUMB;
    } else {
        game.currentEmotion = EMOTIONS.HOPEFUL;
    }

    updateUI();
}

// -----------------------------------------------------------------------------
// UI
// -----------------------------------------------------------------------------
function updateUI() {
    document.getElementById('fragmentCount').textContent = game.fragmentsCollected;
    document.getElementById('emotionEmoji').textContent = game.currentEmotion.emoji;
    document.getElementById('emotionLabel').textContent = game.currentEmotion.name;

    // Time bar
    const timePercent = (game.timeHistory.length / CONFIG.MAX_TIME_HISTORY) * 100;
    document.getElementById('timeBarFill').style.width = timePercent + '%';
}

// -----------------------------------------------------------------------------
// RENDERING
// -----------------------------------------------------------------------------
function draw() {
    // Apply rewind filter if active
    if (game.isRewinding) {
        ctx.filter = 'grayscale(100%) contrast(1.2) sepia(0.2)';
    } else {
        ctx.filter = 'none';
    }

    // Clear
    // Gradient Background
    const bgGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    bgGrad.addColorStop(0, '#0f172a'); // Darker top
    bgGrad.addColorStop(1, '#1e293b'); // Lighter bottom
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Ambient Emotion Tint
    ctx.fillStyle = game.currentEmotion.color;
    ctx.globalAlpha = 0.03;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.globalAlpha = 1;

    // Screen Shake
    ctx.save();
    if (game.shake > 0) {
        const dx = (Math.random() - 0.5) * game.shake;
        const dy = (Math.random() - 0.5) * game.shake;
        ctx.translate(dx, dy);
        game.shake *= 0.9;
        if (game.shake < 0.5) game.shake = 0;
    }

    // Draw Van Gogh Sky (Flow Field)
    brushes.forEach(b => {
        b.x += Math.cos(b.angle) * b.speed;
        b.y += Math.sin(b.angle) * b.speed;
        
        // Wrap around screen
        if (b.x < -20) b.x = canvas.width + 20;
        if (b.x > canvas.width + 20) b.x = -20;
        if (b.y < -20) b.y = canvas.height + 20;
        if (b.y > canvas.height + 20) b.y = -20;

        // Draw stroke
        ctx.strokeStyle = `hsla(${b.hue}, 70%, 40%, 0.1)`;
        ctx.lineWidth = b.width;
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x + Math.cos(b.angle) * b.length, b.y + Math.sin(b.angle) * b.length);
        ctx.stroke();
    });

    // Draw tiles
    const tileSize = CONFIG.TILE_SIZE;
    for (let y = 0; y < game.level.tiles.length; y++) {
        for (let x = 0; x < game.level.tiles[y].length; x++) {
            const tile = game.level.tiles[y][x];

            if (tile === 1) {
                // Solid tile - Stone Ruins
                if (SPRITES.tiles.complete && SPRITES.tiles.naturalWidth !== 0) {
                    // Draw Tile Sprite (Assume 1st tile in sheet is ground)
                    ctx.drawImage(SPRITES.tiles, 0, 0, 32, 32, x * tileSize, y * tileSize, tileSize, tileSize);
                } else {
                    // Fallback Procedural
                    // Base
                    ctx.fillStyle = '#2c3e50';
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    
                    // Brick texture
                    ctx.fillStyle = '#34495e';
                    ctx.fillRect(x * tileSize + 2, y * tileSize + 2, tileSize - 4, tileSize - 4);
                    
                    // Cracks/Details
                    ctx.fillStyle = '#1a252f';
                    ctx.fillRect(x * tileSize + 4, y * tileSize + 14, tileSize - 8, 2);
                    ctx.fillRect(x * tileSize + 14, y * tileSize + 4, 2, tileSize - 8);

                    // Moss on top (if empty above)
                    if (getTile(x, y-1) !== 1) {
                        ctx.fillStyle = '#27ae60'; // Moss green
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, 6);
                        // Moss drips
                        if ((x + y) % 3 === 0) {
                            ctx.fillRect(x * tileSize + 4, y * tileSize + 6, 4, 6);
                        }
                    }
                }

            } else if (tile === 2) {
                // Platform - Old Wood / Vines
                if (SPRITES.tiles.complete && SPRITES.tiles.naturalWidth !== 0) {
                     // Draw Platform Sprite (Use 2nd tile if available, else reuse 1st)
                     const img = SPRITES.tiles;
                     const srcX = (img.width >= 64) ? 32 : 0;
                     ctx.drawImage(img, srcX, 0, 32, 32, x * tileSize, y * tileSize, tileSize, tileSize);
                } else {
                    // Fallback Procedural
                    ctx.fillStyle = game.currentEmotion.canPhase ? '#5d4037' : '#795548';
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, 8);
                }

                if (game.currentEmotion.canPhase) {
                    // Dashed appearance when can phase through
                    ctx.setLineDash([4, 4]);
                    ctx.strokeStyle = '#a1887f';
                    ctx.strokeRect(x * tileSize + 2, y * tileSize + 2, tileSize - 4, 4);
                    ctx.setLineDash([]);
                } else {
                    // Vine hanging
                    if (x % 2 === 0) {
                        ctx.fillStyle = '#2ecc71';
                        ctx.fillRect(x * tileSize + 10, y * tileSize + 8, 4, 6);
                    }
                }
            }
        }
    }

    // Draw ghost trail (rewind effect)
    game.ghostTrail.forEach((ghost, i) => {
        ghost.alpha -= 0.02;
        if (ghost.alpha > 0) {
            ctx.globalAlpha = ghost.alpha * 0.3;
            ctx.fillStyle = '#e67e22'; // Match player color
            ctx.fillRect(ghost.x, ghost.y, ghost.width, ghost.height);
        }
    });
    game.ghostTrail = game.ghostTrail.filter(g => g.alpha > 0);
    ctx.globalAlpha = 1;

    // Draw fragments
    game.fragments.forEach(f => f.draw());

    // Draw particles
    game.particles.forEach(p => p.draw());

    // Draw player
    game.player.draw();

    // Rewind overlay tint
    if (game.isRewinding) {
        ctx.fillStyle = 'rgba(74, 158, 255, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // Vignette (Lighting)
    const gradient = ctx.createRadialGradient(
        canvas.width/2, canvas.height/2, 300,
        canvas.width/2, canvas.height/2, 600
    );
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.restore(); // End screen shake
    
    // Victory Screen
    if (game.won) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 48px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText('MEMORY RESTORED', canvas.width/2, canvas.height/2 - 20);
        
        ctx.fillStyle = '#fff';
        ctx.font = '16px Courier New';
        ctx.fillText('All fragments collected.', canvas.width/2, canvas.height/2 + 20);
        ctx.fillStyle = '#888';
        ctx.fillText('Press R to restart', canvas.width/2, canvas.height/2 + 50);
    }
}

// -----------------------------------------------------------------------------
// GAME LOOP
// -----------------------------------------------------------------------------
function update() {
    if (keys.rewind && game.timeHistory.length > 0) {
        // REWINDING
        game.isRewinding = true;
        rewindTime();
        document.getElementById('rewindIndicator').classList.add('active');
        document.getElementById('rewindOverlay').classList.add('active');
    } else {
        // NORMAL TIME
        game.isRewinding = false;
        document.getElementById('rewindIndicator').classList.remove('active');
        document.getElementById('rewindOverlay').classList.remove('active');

        // Record current state
        recordTime();

        // Update player
        game.player.update();

        // Update fragments
        game.fragments.forEach(f => f.update());
    }

    // Always update particles
    game.particles = game.particles.filter(p => p.update());

    // Update UI
    updateUI();
}

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// -----------------------------------------------------------------------------
// INIT
// -----------------------------------------------------------------------------
loadLevel(LEVEL_1);
gameLoop();

console.log('%c FRAGMENTS ', 'background: #4a9eff; color: #000; font-weight: bold; padding: 4px 8px;');
console.log('A time-rewind platformer');
console.log('Controls: Arrow keys to move, Space to jump, Hold Shift to rewind');
    </script>
</body>
</html>
